/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2020-11-14 21:39:50.509837
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35;
x0=IKcos(j[1]);
x1=IKsin(j[0]);
x2=IKsin(j[4]);
x3=IKsin(j[2]);
x4=IKcos(j[2]);
x5=IKsin(j[1]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[0]);
x9=IKsin(j[3]);
x10=((0.0013229)*x8);
x11=((0.28302638)*x4);
x12=((1.0)*x7);
x13=((0.0013229)*x7);
x14=((0.095638)*x7);
x15=((0.00025)*x8);
x16=((0.095638)*x4);
x17=((0.28302638)*x8);
x18=((1.0)*x4);
x19=((0.00025)*x3);
x20=((0.17468)*x5);
x21=((1.0)*x8);
x22=((0.07773664)*x8);
x23=(x0*x1);
x24=(x0*x4);
x25=(x0*x3);
x26=(x8*x9);
x27=(x1*x9);
x28=(x3*x5);
x29=(x4*x5);
x30=(x6*x7);
x31=((0.095638)*x28);
x32=(x1*x29);
x33=(((x23*x3))+x32);
x34=((((-1.0)*x21*x25))+(((-1.0)*x18*x5*x8)));
x35=(x34*x7);
IkReal x36=((1.0)*x23);
IkReal x37=(x1*x28);
eetrans[0]=(((x2*(((((0.0013229)*x23*x4))+(((-0.0013229)*x37))))))+(((-0.02996689)*x8))+(((-0.07773664)*x23*x3))+((x2*((((x14*x33))+(((-0.095638)*x26))))))+((x9*((((x19*x23))+(((0.00025)*x32))))))+(((-1.0)*x1*x20))+(((0.28302638)*x37))+(((-1.0)*x11*x36))+((x6*((((x1*x31))+(((-1.0)*x16*x36))))))+(((0.02950006)*x1))+((x6*(((((-1.0)*x10*x9))+((x13*x33))))))+(((-0.07773664)*x32))+((x15*x7))+(((5.0e-5)*x23)));
IkReal x38=((1.0)*x15);
IkReal x39=(x0*x8);
eetrans[1]=((((-0.02996689)*x1))+((x22*x29))+((x22*x25))+((x2*(((((-1.0)*x10*x24))+((x10*x28))))))+(((0.00025)*x1*x7))+((x6*((((x16*x39))+(((-1.0)*x31*x8))))))+((x2*((((x14*x34))+(((-0.095638)*x27))))))+((x11*x39))+(((-1.0)*x17*x28))+((x6*((((x13*x34))+(((-0.0013229)*x27))))))+(((-0.02950006)*x8))+((x9*(((((-1.0)*x29*x38))+(((-1.0)*x25*x38))))))+(((-5.0e-5)*x39))+((x20*x8)));
IkReal x40=((1.0)*x16);
eetrans[2]=((0.153975)+(((0.07773664)*x24))+((x2*(((((0.0013229)*x29))+(((0.0013229)*x25))))))+((x6*(((((-1.0)*x40*x5))+(((-0.095638)*x25))))))+(((-1.0)*x11*x5))+(((-0.28302638)*x25))+((x30*(((((0.0013229)*x28))+(((-0.0013229)*x24))))))+((x9*((((x19*x5))+(((-0.00025)*x24))))))+(((0.17468)*x0))+((x2*x7*(((((-1.0)*x0*x40))+x31))))+(((5.0e-5)*x5))+(((-0.07773664)*x28)));
eerot[0]=(((x6*(((((-1.0)*x12*x33))+((x21*x9))))))+((x2*((((x1*x28))+(((-1.0)*x18*x23)))))));
eerot[1]=(((x2*(((((-1.0)*x21*x28))+((x24*x8))))))+((x6*(((((-1.0)*x12*x34))+(((1.0)*x27)))))));
eerot[2]=(((x2*(((((-1.0)*x18*x5))+(((-1.0)*x25))))))+((x30*((((x0*x18))+(((-1.0)*x28)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=px;
new_r01=r01;
new_py=py;
new_r02=r02;
new_pz=((-0.153975)+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
IkReal op[72], zeror[48];
int numroots;;
IkReal x41=px*px;
IkReal x42=py*py;
IkReal x43=pz*pz;
IkReal x44=((1.0121560816)*px);
IkReal x45=((0.15547328)*py);
IkReal x46=((4.0050259041779)*r02);
IkReal x47=((6.48891217834638)*r02);
IkReal x48=((20.9926418974003)*r00);
IkReal x49=((0.19388672)*pz);
IkReal x50=((0.05993378)*px);
IkReal x51=((0.0169645865530291)*r02);
IkReal x52=((0.000156668322215019)*px);
IkReal x53=((0.00131964616575002)*pz);
IkReal x54=((0.142880928485403)*r00);
IkReal x55=((0.000406410840879148)*py);
IkReal x56=((0.0026458)*px);
IkReal x57=((0.0104692326904)*r02);
IkReal x58=((0.0026458)*pz);
IkReal x59=((0.0104692326904)*r00);
IkReal x60=((0.0026458)*py);
IkReal x61=((0.0017710467950268)*r00);
IkReal x62=((0.0052916)*pz);
IkReal x63=((0.0052916)*py);
IkReal x64=((0.0035361002120536)*r00);
IkReal x65=((0.0017650534170268)*r00);
IkReal x66=((0.31094656)*px);
IkReal x67=((2.0243121632)*py);
IkReal x68=((41.9852837948006)*r01);
IkReal x69=((0.11986756)*py);
IkReal x70=((0.000313336644430038)*py);
IkReal x71=((0.285761856970806)*r01);
IkReal x72=((0.000812821681758297)*px);
IkReal x73=((0.0209384653808)*r01);
IkReal x74=((0.0052916)*px);
IkReal x75=((0.0035420935900536)*r01);
IkReal x76=((0.0070722004241072)*r01);
IkReal x77=((0.0035301068340536)*r01);
IkReal x78=((30.0968608140315)*r00);
IkReal x79=((5.81185685315928)*r01);
IkReal x80=((0.05910012)*py);
IkReal x81=((7.8183548748e-5)*r01);
IkReal x82=((7.88526967428401)*r00);
IkReal x83=((0.31094656)*pz);
IkReal x84=((12.9764559146401)*r02);
IkReal x85=((8.0100518083558)*r01);
IkReal x86=((2.6458e-7)*r02);
IkReal x87=((12.9778243566928)*r01);
IkReal x88=((0.0002)*pz);
IkReal x89=((12.7761582965215)*r00);
IkReal x90=((0.38777344)*py);
IkReal x91=((7.16459906148081)*r01);
IkReal x92=((42.8707620491624)*r00);
IkReal x93=((0.05890012)*py);
IkReal x94=((7.7918968748e-5)*r01);
IkReal x95=((0.000154489115205253)*py);
IkReal x96=((2.04373650505029e-7)*r01);
IkReal x97=((0.0187344252290446)*r01);
IkReal x98=((0.112127693939902)*r00);
IkReal x99=((0.0339291731060581)*r01);
IkReal x100=((0.00263929233150003)*py);
IkReal x101=((6.91618394362074e-10)*r02);
IkReal x102=((0.0333971807663312)*r00);
IkReal x103=((5.22804742884627e-7)*pz);
IkReal x104=((0.0206122819232)*r00);
IkReal x105=((0.0339327502460356)*r02);
IkReal x106=((0.000812821681758297)*pz);
IkReal x107=((0.000153966310462369)*py);
IkReal x108=((2.03682032110667e-7)*r01);
IkReal x109=((0.015198325016991)*r01);
IkReal x110=((0.0787246131615707)*r00);
IkReal x111=((0.0315297024870941)*r02);
IkReal x112=((0.0885544871552)*r01);
IkReal x113=((0.0057293642092032)*r02);
IkReal x114=((0.0803783156658525)*r01);
IkReal x115=((0.1977212562336)*r02);
IkReal x116=((0.092969671568505)*r01);
IkReal x117=((0.164243545503719)*r02);
IkReal x118=((1.9388672e-5)*r01);
IkReal x119=((0.1091667690784)*r01);
IkReal x120=((0.0649209832414253)*r02);
IkReal x121=((0.0057099755372032)*r02);
IkReal x122=((0.0803842156778525)*r01);
IkReal x123=((0.134694460766653)*r01);
IkReal x124=((0.0149178537139968)*r02);
IkReal x125=((0.0649834885294253)*r02);
IkReal x126=((0.1092017050784)*r01);
IkReal x127=((5.0483328e-5)*r01);
IkReal x128=((0.272875835705319)*r02);
IkReal x129=((0.093082882120505)*r01);
IkReal x130=((0.1977911282336)*r02);
IkReal x131=((0.134700360778652)*r01);
IkReal x132=((0.0148673703859968)*r02);
IkReal x133=((0.0885894231552)*r01);
IkReal x134=((0.0315804077510941)*r02);
IkReal x135=(pz*r01);
IkReal x136=(pz*r02);
IkReal x137=(px*r02);
IkReal x138=(py*r01);
IkReal x139=((4.0)*r00);
IkReal x140=((4.0)*px);
IkReal x141=((1.0)*r02);
IkReal x142=((382.552)*r00);
IkReal x143=(px*r00);
IkReal x144=((765.104)*px);
IkReal x145=(pz*r00);
IkReal x146=(px*r01);
IkReal x147=((1530.208)*py);
IkReal x148=((1.0)*r01);
IkReal x149=((4.0)*py);
IkReal x150=(py*r00);
IkReal x151=(py*r02);
IkReal x152=((2.0)*r01);
IkReal x153=((765.104)*r01);
IkReal x154=((2.0)*px);
IkReal x155=((2.0)*py);
IkReal x156=((8.0)*px);
IkReal x157=((133.64836672)*x145);
IkReal x158=((133.64836672)*x137);
IkReal x159=((22.92778740656)*x143);
IkReal x160=((22.92778740656)*x138);
IkReal x161=((22.92778740656)*x136);
IkReal x162=((216.54461544352)*x137);
IkReal x163=((216.54461544352)*x145);
IkReal x164=((1.0)*x41);
IkReal x165=(r01*x60);
IkReal x166=((1.0)*x42);
IkReal x167=(r02*x58);
IkReal x168=((1.0)*x43);
IkReal x169=(r00*x56);
IkReal x170=((6.91618394362074e-6)*x143);
IkReal x171=((0.00261402371442314)*x43);
IkReal x172=((0.56605276)*x137);
IkReal x173=((0.00261402371442314)*x42);
IkReal x174=((6.91618394362074e-6)*x138);
IkReal x175=((6.91618394362074e-6)*x136);
IkReal x176=((0.00261402371442314)*x41);
IkReal x177=((0.56605276)*x145);
IkReal x178=(r00*x43);
IkReal x179=((0.34936)*x145);
IkReal x180=(r00*x42);
IkReal x181=((0.05993378)*x136);
IkReal x182=((0.34936)*x137);
IkReal x183=((0.05993378)*x138);
IkReal x184=(r00*x50);
IkReal x185=((0.05993378)*x145);
IkReal x186=((0.34936)*x143);
IkReal x187=((0.34936)*x138);
IkReal x188=((0.34936)*x136);
IkReal x189=(r02*x50);
IkReal x190=((0.05993378)*x150);
IkReal x191=((0.19388672)*x151);
IkReal x192=(r01*x49);
IkReal x193=(r01*x50);
IkReal x194=(r01*x80);
IkReal x195=((0.05910012)*x136);
IkReal x196=((0.05910012)*x143);
IkReal x197=(r01*x42);
IkReal x198=(r02*x42);
IkReal x199=(r02*x41);
IkReal x200=((0.11800024)*x151);
IkReal x201=((0.11986756)*x137);
IkReal x202=((0.11986756)*x145);
IkReal x203=((0.11800024)*x135);
IkReal x204=((0.11986756)*x146);
IkReal x205=((0.11800024)*x136);
IkReal x206=((0.11800024)*x138);
IkReal x207=((0.11800024)*x143);
IkReal x208=(r00*x69);
IkReal x209=(r01*x41);
IkReal x210=((0.50483328)*x135);
IkReal x211=(r01*x43);
IkReal x212=((0.05890012)*x143);
IkReal x213=((0.50483328)*x151);
IkReal x214=(r01*x93);
IkReal x215=((0.05890012)*x136);
IkReal x216=(r02*x43);
IkReal x217=((267.29673344)*x135);
IkReal x218=((267.29673344)*x151);
IkReal x219=((433.08923088704)*x151);
IkReal x220=((433.08923088704)*x135);
IkReal x221=((1.13210552)*x151);
IkReal x222=((1.13210552)*x135);
IkReal x223=((0.69872)*x135);
IkReal x224=((0.69872)*x151);
IkReal x225=((0.11986756)*x135);
IkReal x226=(r02*x69);
IkReal x227=((0.38777344)*x145);
IkReal x228=((0.38777344)*x137);
IkReal x229=((0.23600048)*x145);
IkReal x230=((0.23973512)*x151);
IkReal x231=((1.00966656)*x137);
IkReal x232=((1.00966656)*x145);
IkReal x233=((193.93574633728)*x146);
IkReal x234=((193.93574633728)*x150);
IkReal x235=((433.01272048704)*x137);
IkReal x236=((267.29673344)*x146);
IkReal x237=((267.29673344)*x150);
IkReal x238=((433.01272048704)*x145);
IkReal x239=((433.08923088704)*x150);
IkReal x240=((433.08923088704)*x146);
IkReal x241=((239.07697414976)*x150);
IkReal x242=((239.07697414976)*x146);
IkReal x243=((0.62515288)*x150);
IkReal x244=((0.62515288)*x146);
IkReal x245=((1.13210552)*x150);
IkReal x246=((1.13210552)*x146);
IkReal x247=((0.69872)*x146);
IkReal x248=((1.13230552)*x145);
IkReal x249=((0.69872)*x150);
IkReal x250=((1.13230552)*x137);
IkReal x251=((0.50715264)*x146);
IkReal x252=(r00*x41);
IkReal x253=((0.50715264)*x150);
IkReal x254=((0.50695264)*x151);
IkReal x255=((0.50695264)*x135);
IkReal x256=((0.62495288)*x151);
IkReal x257=((0.62495288)*x135);
IkReal x258=((0.62515288)*x135);
IkReal x259=((0.62515288)*x151);
IkReal x260=((0.50715264)*x135);
IkReal x261=((0.50715264)*x151);
IkReal x262=((7.7918968748e-5)+x121);
IkReal x263=((-7.8183548748e-5)+x113);
IkReal x264=(x142*x43);
IkReal x265=(x142*x42);
IkReal x266=(x138*x144);
IkReal x267=(x142*x41);
IkReal x268=(x136*x144);
IkReal x269=(x138*x154);
IkReal x270=(r00*x164);
IkReal x271=(x136*x154);
IkReal x272=((2.0)*pz*x143);
IkReal x273=(x135*x155);
IkReal x274=(x143*x155);
IkReal x275=(x136*x155);
IkReal x276=(x148*x43);
IkReal x277=(x148*x41);
IkReal x278=(x141*x43);
IkReal x279=((2.0)*x198);
IkReal x280=((2.0)*x199);
IkReal x281=(x135*x149);
IkReal x282=((2.0)*x216);
IkReal x283=(px*pz*x139);
IkReal x284=(x152*x43);
IkReal x285=(x152*x41);
IkReal x286=(x136*x149);
IkReal x287=(x152*x42);
IkReal x288=(px*py*x139);
IkReal x289=(x148*x42);
IkReal x290=(x141*x42);
IkReal x291=(x141*x41);
IkReal x292=(x153*x43);
IkReal x293=(x153*x41);
IkReal x294=(x153*x42);
IkReal x295=(x143*x147);
IkReal x296=(x136*x147);
IkReal x297=((2.0)*x178);
IkReal x298=((2.0)*x180);
IkReal x299=((2.0)*x252);
IkReal x300=(x136*x140);
IkReal x301=(x138*x140);
IkReal x302=(x139*x43);
IkReal x303=(x139*x42);
IkReal x304=(r00*x168);
IkReal x305=(r00*x166);
IkReal x306=(x100+x99);
IkReal x307=((-7.78592821367908e-5)+x245);
IkReal x308=((7.8183548748e-5)+x190);
IkReal x309=(x89+x90);
IkReal x310=(x48+x50);
IkReal x311=(x93+x94);
IkReal x312=(x51+x53);
IkReal x313=((-0.0789129070096614)+x241);
IkReal x314=(x68+x69);
IkReal x315=((-0.000156102517496)+x204);
IkReal x316=(x110+x109);
IkReal x317=(x80+x81);
IkReal x318=((-0.00018234256300024)+x251);
IkReal x319=(x238+x85);
IkReal x320=(x253+x57);
IkReal x321=(x226+x73);
IkReal x322=(x250+x73);
IkReal x323=(x114+x191);
IkReal x324=(x235+x82);
IkReal x325=(x185+x59);
IkReal x326=(x119+x257);
IkReal x327=(x225+x73);
IkReal x328=(x112+x254);
IkReal x329=(x122+x192);
IkReal x330=(x177+x54);
IkReal x331=(x224+x72);
IkReal x332=(x217+x66);
IkReal x333=(x131+x210);
IkReal x334=(x210+x61);
IkReal x335=(x163+x47);
IkReal x336=(x189+x59);
IkReal x337=(x172+x54);
IkReal x338=(x191+x65);
IkReal x339=(x126+x259);
IkReal x340=(x179+x55);
IkReal x341=(x104+x248);
IkReal x342=(x162+x49);
IkReal x343=(x182+x98);
IkReal x344=(x123+x213);
IkReal x345=(x163+x49);
IkReal x346=(x162+x47);
IkReal x347=(x158+x45);
IkReal x348=((((0.23600048)*x137))+(((0.23973512)*x135)));
IkReal x349=(x189+x256);
IkReal x350=(x211+x209);
IkReal x351=(x193+x197);
IkReal x352=(x115+x315);
IkReal x353=(x201+x200);
IkReal x354=(x229+x230);
IkReal x355=((-0.000206320851381411)+x243+x57);
IkReal x356=(x178+x180);
IkReal x357=((-0.0697399648328678)+x233+x46);
IkReal x358=(x101+x103+x246);
IkReal x359=(x105+x106+x247);
IkReal x360=(x237+x83+x84);
IkReal x361=(x177+x95+x96);
IkReal x362=(x172+x108+x107);
IkReal x363=(x127+x203+x202);
IkReal x364=(x285+x284);
IkReal x365=(x290+x291);
IkReal x366=(x292+x293);
IkReal x367=(x133+x189+x260);
IkReal x368=((0.0114393397464064)+x239+x88+x86);
IkReal x369=(x118+x203+x202);
IkReal x370=(x196+x195+x194);
IkReal x371=(x128+x279+x280);
IkReal x372=(x298+x297+x77);
IkReal x373=(x298+x297+x75);
IkReal x374=(x302+x303+x76);
IkReal x375=(x117+x279+x280);
IkReal x376=(x190+x276+x277);
IkReal x377=(x193+x276+x277);
IkReal x378=(x190+x212+x214+x215);
IkReal x379=(x207+x206+x205+x208);
IkReal x380=(x265+x264+x79+x78);
IkReal x381=(x160+x161+x159+x234);
IkReal x382=(x157+x265+x264+x92);
IkReal x383=(x197+x274+x275+x60);
IkReal x384=(x252+x269+x271+x56);
IkReal x385=(((x136*x156))+(((0.0105832)*px))+((x138*x156))+((x139*x41)));
IkReal x386=(x300+x301+x299+x74);
IkReal x387=(x160+x161+x159+x242+x46);
IkReal x388=(x272+x273+x278+x58);
IkReal x389=(x288+x287+x286+x63);
IkReal x390=(x379+x64);
IkReal x391=(x294+x295+x296+x67);
IkReal x392=(x283+x282+x281+x62);
IkReal x393=(x213+x274+x275+x60+x65);
IkReal x394=(x192+x274+x275+x60+x61);
IkReal x395=((0.000462168344)+x199+x198+x186+x187+x188);
IkReal x396=(x267+x266+x268+x44+x91);
IkReal x397=(x185+x388);
IkReal x398=(x184+x181+x183+x304+x305);
IkReal x399=(x193+x274+x275+x289+x60);
IkReal x400=(x157+x267+x266+x268+x44);
IkReal x401=(x171+x170+x173+x175+x174+x176);
IkReal x402=(x168+x169+x166+x167+x164+x165);
IkReal x403=(x353+x392);
IkReal x404=(x401+x52);
IkReal x405=(x184+x181+x183+x269+x270+x271+x56);
IkReal x406=((0.000462168344)+x186+x187+x188+x216+x272+x273+x58);
op[0]=(x357+x380+x347+(((-1.0)*x381))+(((-1.0)*x400)));
op[1]=((0.0780796356651291)+x345+(((-1.0)*x310))+(((-1.0)*x317))+(((-1.0)*x346))+(((-1.0)*x402)));
op[2]=((((-1.0)*x360))+(((-1.0)*x324))+x319+x236);
op[3]=(x309+x368+(((-1.0)*x240))+(((-1.0)*x87)));
op[4]=((((-1.0)*x396))+x313+x382+(((-1.0)*x387))+(((-1.0)*x347)));
op[5]=((0.0780855356771291)+x346+(((-1.0)*x310))+(((-1.0)*x311))+(((-1.0)*x345))+(((-1.0)*x402)));
op[6]=((-6.21183278726267e-5)+x361+(((-1.0)*x312))+x404+(((-1.0)*x337)));
op[7]=(x355+x356+x343+(((-1.0)*x97))+(((-1.0)*x244))+(((-1.0)*x340))+(((-1.0)*x405)));
op[8]=((((-1.0)*x358))+x102+x307+(((-1.0)*x306)));
op[9]=(x322+x359+(((-1.0)*x249))+(((-1.0)*x341)));
op[10]=((-6.21337506439101e-5)+x312+x362+x404+(((-1.0)*x330)));
op[11]=((((-1.0)*x182))+(((-1.0)*x320))+x356+x318+x316+x340+(((-1.0)*x405)));
op[12]=((((-1.0)*x397))+(((-1.0)*x328))+x111+x336+x395+x255);
op[13]=((((-1.0)*x394))+(((-1.0)*x370))+(((-1.0)*x190))+x193+x323+x350+x263+(((-1.0)*x289)));
op[14]=((((-1.0)*x390))+x116+x352+x364+(((-1.0)*x389)));
op[15]=((((-1.0)*x353))+(((-1.0)*x375))+x369+x392);
op[16]=((((-1.0)*x365))+(((-1.0)*x120))+x325+x326+x406+(((-1.0)*x349)));
op[17]=((((-1.0)*x377))+(((-1.0)*x329))+x338+x383+x378+x262);
op[18]=((((-1.0)*x377))+(((-1.0)*x124))+x308+x334+x383+x370+(((-1.0)*x344)));
op[19]=((((-1.0)*x397))+x125+x339+x336+x395+(((-1.0)*x258)));
op[20]=((((-1.0)*x392))+(((-1.0)*x363))+x353+x371);
op[21]=((((-1.0)*x390))+x129+x315+x364+(((-1.0)*x130))+(((-1.0)*x389)));
op[22]=((-7.7918968748e-5)+(((-1.0)*x393))+(((-1.0)*x378))+x193+x333+x350+(((-1.0)*x132))+(((-1.0)*x289)));
op[23]=((((-1.0)*x367))+(((-1.0)*x365))+x325+(((-1.0)*x134))+x261+x406);
op[24]=((((-11.6237137063186)*r00))+(((-1.0)*x391))+(((60.1937216280629)*r01))+x366+x218+(((-1.0)*x332)));
op[25]=((((0.000156367097496)*r00))+x220+(((-1.0)*x314))+(((0.11820024)*px))+(((-1.0)*x219)));
op[26]=((((-15.770539348568)*r01))+(((866.02544097408)*x135))+(((-866.02544097408)*x151))+(((-16.0201036167116)*r00)));
op[27]=((((25.9556487133855)*r00))+(((-0.77554688)*px))+(((25.5523165930431)*r01)));
op[28]=((((-1.0)*x391))+x332+x366+(((85.7415240983247)*r01))+(((14.3291981229616)*r00))+(((-1.0)*x218)));
op[29]=(x219+(((-1.0)*x314))+(((0.11780024)*px))+(((0.000155837937496)*r00))+(((-1.0)*x220)));
op[30]=((((-1.0)*x71))+(((-0.000308978230410506)*px))+x222+(((-4.08747301010059e-7)*r00))+x70+(((-1.0)*x221)));
op[31]=((((0.224255387879804)*r01))+(((0.0374688504580892)*r00))+x331+x364+(((-1.0)*x389))+(((-1.0)*x223)));
op[32]=((((0.0678583462121163)*r00))+(((0.00527858466300006)*px))+(((0.0667943615326624)*r01)));
op[33]=((((-2.26461104)*x135))+(((-0.0418769307616)*r00))+(((2.26461104)*x151))+(((-0.0412245638464)*r01)));
op[34]=((((-0.000307932620924737)*px))+(((-1.0)*x71))+x221+(((-4.07364064221335e-7)*r00))+x70+(((-1.0)*x222)));
op[35]=((((0.157449226323141)*r01))+x364+x223+(((-1.0)*x389))+(((-1.0)*x331))+(((-0.030396650033982)*r00)));
op[36]=((((0.1771089743104)*r00))+(((-1.01390528)*x145))+x321+(((-1.0)*x225))+(((1.01390528)*x137)));
op[37]=((((-1.0)*x373))+x386+x227+(((-0.160756631331705)*r00))+(((-1.0)*x228)));
op[38]=((((-1.0)*x374))+x385+(((-0.18593934313701)*r00)));
op[39]=((((-3.8777344e-5)*r00))+(((-1.0)*x354))+x348);
op[40]=((((-1.24990576)*x145))+x327+(((1.24990576)*x137))+(((-0.2183335381568)*r00))+(((-1.0)*x226)));
op[41]=((((0.160768431355705)*r00))+x372+x227+(((-1.0)*x386))+(((-1.0)*x228)));
op[42]=((((0.269388921533305)*r00))+x373+(((-1.0)*x232))+x231+(((-1.0)*x386)));
op[43]=((((-0.2184034101568)*r00))+(((1.25030576)*x145))+x321+(((-1.25030576)*x137))+(((-1.0)*x225)));
op[44]=((((0.000100966656)*r00))+x354+(((-1.0)*x348)));
op[45]=((((-1.0)*x374))+x385+(((-0.18616576424101)*r00)));
op[46]=((((-1.0)*x372))+x386+(((-1.0)*x232))+x231+(((-0.269400721557305)*r00)));
op[47]=(x327+(((1.01430528)*x145))+(((-1.01430528)*x137))+(((0.1771788463104)*r00))+(((-1.0)*x226)));
op[48]=(x357+x400+(((-1.0)*x381))+(((-1.0)*x380))+(((-1.0)*x347)));
op[49]=((0.0780796356651291)+x317+x310+x342+(((-1.0)*x335))+(((-1.0)*x402)));
op[50]=((((-1.0)*x360))+x324+x236+(((-1.0)*x319)));
op[51]=(x368+x87+(((-1.0)*x240))+(((-1.0)*x309)));
op[52]=(x313+x347+x396+(((-1.0)*x382))+(((-1.0)*x387)));
op[53]=((0.0780855356771291)+x335+x311+x310+(((-1.0)*x342))+(((-1.0)*x402)));
op[54]=((-6.21183278726267e-5)+(((-1.0)*x361))+x337+(((-1.0)*x312))+x401+(((-1.0)*x52)));
op[55]=((((-1.0)*x398))+x355+x384+x340+x97+(((-1.0)*x244))+(((-1.0)*x343)));
op[56]=((((-1.0)*x358))+(((-1.0)*x102))+x306+x307);
op[57]=((((-1.0)*x322))+x359+x341+(((-1.0)*x249)));
op[58]=((-6.21337506439101e-5)+(((-1.0)*x362))+x330+x312+x401+(((-1.0)*x52)));
op[59]=((((-1.0)*x398))+(((-1.0)*x320))+x182+x318+x384+(((-1.0)*x316))+(((-1.0)*x340)));
op[60]=(x111+x185+x328+x395+(((-1.0)*x388))+(((-1.0)*x336))+(((-1.0)*x255)));
op[61]=((((-1.0)*x376))+(((-1.0)*x370))+(((-1.0)*x323))+x351+x394+x263);
op[62]=((((-1.0)*x364))+(((-1.0)*x379))+(((-1.0)*x116))+x352+x389+x64);
op[63]=((((-1.0)*x369))+(((-1.0)*x375))+x403);
op[64]=((((-1.0)*x365))+(((-1.0)*x326))+(((-1.0)*x325))+(((-1.0)*x120))+x349+x406);
op[65]=((((-1.0)*x399))+x329+x350+x378+x262+(((-1.0)*x338)));
op[66]=((((-1.0)*x399))+(((-1.0)*x124))+x308+x350+x344+x370+(((-1.0)*x334)));
op[67]=(x125+x185+x395+x258+(((-1.0)*x388))+(((-1.0)*x339))+(((-1.0)*x336)));
op[68]=(x371+x363+(((-1.0)*x403)));
op[69]=((((-1.0)*x364))+(((-1.0)*x379))+(((-1.0)*x129))+x315+x389+(((-1.0)*x130))+x64);
op[70]=((-7.7918968748e-5)+(((-1.0)*x376))+x351+x393+(((-1.0)*x132))+(((-1.0)*x333))+(((-1.0)*x212))+(((-1.0)*x215))+(((-1.0)*x214)));
op[71]=((((-1.0)*x365))+(((-1.0)*x325))+x367+(((-1.0)*x134))+x406+(((-1.0)*x261)));
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j0array[16], cj0array[16], sj0array[16], j1array[16], cj1array[16], sj1array[16], j2array[16], cj2array[16], sj2array[16];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ij0 += 3)
{
IkReal htj0 = zeror[ij0+0], htj1 = zeror[ij0+1], htj2 = zeror[ij0+2];
if(isnan(htj0)||isnan(htj1)||isnan(htj2)){
continue;
}
j0array[numsolutions]=((2.0)*(atan(htj0)));
j1array[numsolutions]=((2.0)*(atan(htj1)));
j2array[numsolutions]=((2.0)*(atan(htj2)));
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x407=htj0*htj0;
CheckValue<IkReal> x408=IKPowWithIntegerCheck(((1.0)+x407),-1);
if(!x408.valid){
continue;
}
cj0array[numsolutions]=((x408.value)*(((1.0)+(((-1.0)*x407)))));
CheckValue<IkReal> x409=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x409.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x409.value));
}
if(isinf(htj1)){
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
}
else{
IkReal x410=htj1*htj1;
CheckValue<IkReal> x411=IKPowWithIntegerCheck(((1.0)+x410),-1);
if(!x411.valid){
continue;
}
cj1array[numsolutions]=((x411.value)*(((1.0)+(((-1.0)*x410)))));
CheckValue<IkReal> x412=IKPowWithIntegerCheck(((1.0)+(htj1*htj1)),-1);
if(!x412.valid){
continue;
}
sj1array[numsolutions]=((2.0)*htj1*(x412.value));
}
if(isinf(htj2)){
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
}
else{
IkReal x413=htj2*htj2;
CheckValue<IkReal> x414=IKPowWithIntegerCheck(((1.0)+x413),-1);
if(!x414.valid){
continue;
}
cj2array[numsolutions]=((x414.value)*(((1.0)+(((-1.0)*x413)))));
CheckValue<IkReal> x415=IKPowWithIntegerCheck(((1.0)+(htj2*htj2)),-1);
if(!x415.valid){
continue;
}
sj2array[numsolutions]=((2.0)*htj2*(x415.value));
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j0valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj0 = 16;
_nj1 = 1;
_nj2 = 1;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
_ij1[0] = 0; _ij1[1] = -1;
_ij2[0] = 0; _ij2[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( !j0valid[iij0] ) { continue; }
if( IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj1array[ij0]-cj1array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij0]-sj1array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj2array[ij0]-cj2array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij0]-sj2array[iij0]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j0valid[iij0]=false; _ij0[1] = iij0; _ij1[1] = 0; _ij2[1] = 0;  break; 
}
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

    j1 = j1array[ij0]; cj1 = cj1array[ij0]; sj1 = sj1array[ij0];

    j2 = j2array[ij0]; cj2 = cj2array[ij0]; sj2 = sj2array[ij0];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j4eval[1];
j4eval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3, j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x416=sj2*sj2;
IkReal x417=cj2*cj2;
IkReal x418=(sj1*sj2);
IkReal x419=(cj2*sj1);
IkReal x420=((0.0013229)*pz);
IkReal x421=(cj1*sj2);
IkReal x422=(cj0*r01);
IkReal x423=(cj1*cj2);
IkReal x424=(r00*sj0);
IkReal x425=((0.0013229)*cj0*py);
IkReal x426=((0.0013229)*px*sj0);
CheckValue<IkReal> x429=IKPowWithIntegerCheck((x416+x417),-1);
if(!x429.valid){
continue;
}
IkReal x427=x429.value;
IkReal x428=(((r02*x421))+(((-1.0)*x422*x423))+((x418*x422))+(((-1.0)*x418*x424))+((x423*x424))+((r02*x419)));
CheckValue<IkReal> x430=IKPowWithIntegerCheck(((((0.0001265195102)*x417))+(((0.0001265195102)*x416))),-1);
if(!x430.valid){
continue;
}
if( IKabs(((-1.0)*x427*x428)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x427*(x430.value)*((((x428*(((((-1.75006441e-6)*x417))+(((-1.75006441e-6)*x416))))))+(((((((-1.0)*x417))+(((-1.0)*x416))))*(((((-3.9025629374e-5)*x423))+((x420*x421))+(((-0.000231084172)*sj2))+(((-6.6145e-8)*cj2))+((x418*x425))+((x419*x420))+((x423*x426))+(((-1.0)*x418*x426))+(((-1.0)*x423*x425))+(((3.9025629374e-5)*x418))+(((0.000374415598102)*x417))+(((0.000374415598102)*x416)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*x427*x428))+IKsqr((x427*(x430.value)*((((x428*(((((-1.75006441e-6)*x417))+(((-1.75006441e-6)*x416))))))+(((((((-1.0)*x417))+(((-1.0)*x416))))*(((((-3.9025629374e-5)*x423))+((x420*x421))+(((-0.000231084172)*sj2))+(((-6.6145e-8)*cj2))+((x418*x425))+((x419*x420))+((x423*x426))+(((-1.0)*x418*x426))+(((-1.0)*x423*x425))+(((3.9025629374e-5)*x418))+(((0.000374415598102)*x417))+(((0.000374415598102)*x416))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*x427*x428), (x427*(x430.value)*((((x428*(((((-1.75006441e-6)*x417))+(((-1.75006441e-6)*x416))))))+(((((((-1.0)*x417))+(((-1.0)*x416))))*(((((-3.9025629374e-5)*x423))+((x420*x421))+(((-0.000231084172)*sj2))+(((-6.6145e-8)*cj2))+((x418*x425))+((x419*x420))+((x423*x426))+(((-1.0)*x418*x426))+(((-1.0)*x423*x425))+(((3.9025629374e-5)*x418))+(((0.000374415598102)*x417))+(((0.000374415598102)*x416))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x431=cj2*cj2;
IkReal x432=IKsin(j4);
IkReal x433=sj2*sj2;
IkReal x434=IKcos(j4);
IkReal x435=(sj1*sj2);
IkReal x436=(cj2*sj1);
IkReal x437=((0.0013229)*pz);
IkReal x438=(cj1*sj2);
IkReal x439=(cj0*r01);
IkReal x440=(cj1*cj2);
IkReal x441=((0.095638)*pz);
IkReal x442=(r00*sj0);
IkReal x443=(cj0*py);
IkReal x444=((0.095638)*px*sj0);
IkReal x445=((0.0013229)*px*sj0);
IkReal x446=((((0.0001265195102)*x433))+(((0.0001265195102)*x431)));
evalcond[0]=((((-1.0)*x435*x442))+((r02*x438))+((r02*x436))+((x440*x442))+((x432*((x431+x433))))+(((-1.0)*x439*x440))+((x435*x439)));
evalcond[1]=(((x436*x437))+((x434*x446))+(((-1.0)*x435*x445))+(((-0.000231084172)*sj2))+(((-6.6145e-8)*cj2))+((x432*(((((-1.75006441e-6)*x431))+(((-1.75006441e-6)*x433))))))+((x440*x445))+(((-0.0013229)*x440*x443))+(((3.9025629374e-5)*x435))+(((0.000374415598102)*x431))+(((0.000374415598102)*x433))+(((-3.9025629374e-5)*x440))+((x437*x438))+(((0.0013229)*x435*x443)));
evalcond[2]=((((-1.0)*x435*x444))+(((-1.0)*x432*x446))+(((-0.095638)*x440*x443))+(((0.00282132673828)*x435))+(((0.095638)*x435*x443))+((x434*(((((0.009146627044)*x433))+(((0.009146627044)*x431))))))+((x440*x444))+(((-4.7819e-6)*cj2))+(((-0.01670604584)*sj2))+(((0.02706807693044)*x433))+(((0.02706807693044)*x431))+((x438*x441))+(((-0.00282132673828)*x440))+((x436*x441)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=cj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x447=((10.4560234104301)*cj0);
IkReal x448=(py*sj0);
IkReal x449=(cj1*py);
IkReal x450=(pz*sj1);
IkReal x451=((0.0273322931534277)*cj0);
IkReal x452=(cj1*px*sj0);
if( IKabs(((-0.311211149359198)+(((-10.4560234104301)*x448))+(((0.0273322931534277)*x452))+(((0.0273322931534277)*x450))+(((-0.000806304287963707)*cj1))+(((-1.0)*px*x447))+(((-1.0)*x449*x451)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.81311239034003)+(((10.4560234104301)*x450))+(((10.4560234104301)*x452))+(((-0.308453317969092)*cj1))+(((-1.0)*x447*x449))+((px*x451))+(((0.0273322931534277)*x448)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311211149359198)+(((-10.4560234104301)*x448))+(((0.0273322931534277)*x452))+(((0.0273322931534277)*x450))+(((-0.000806304287963707)*cj1))+(((-1.0)*px*x447))+(((-1.0)*x449*x451))))+IKsqr(((0.81311239034003)+(((10.4560234104301)*x450))+(((10.4560234104301)*x452))+(((-0.308453317969092)*cj1))+(((-1.0)*x447*x449))+((px*x451))+(((0.0273322931534277)*x448))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.311211149359198)+(((-10.4560234104301)*x448))+(((0.0273322931534277)*x452))+(((0.0273322931534277)*x450))+(((-0.000806304287963707)*cj1))+(((-1.0)*px*x447))+(((-1.0)*x449*x451))), ((0.81311239034003)+(((10.4560234104301)*x450))+(((10.4560234104301)*x452))+(((-0.308453317969092)*cj1))+(((-1.0)*x447*x449))+((px*x451))+(((0.0273322931534277)*x448))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x453=IKcos(j3);
IkReal x454=IKsin(j3);
IkReal x455=((1.0)*px);
evalcond[0]=((-0.02996689)+(((-1.0)*cj0*x455))+(((0.00025)*x453))+(((-1.0)*py*sj0))+(((-0.095638)*x454)));
evalcond[1]=((-0.07768664)+(((0.00025)*x454))+(((0.02950006)*cj1))+(((-1.0)*pz*sj1))+((cj0*cj1*py))+(((-1.0)*cj1*sj0*x455))+(((0.095638)*x453)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x456=((0.0273322931534277)*px);
IkReal x457=(cj1*sj0);
IkReal x458=((10.4560234104301)*cj0);
IkReal x459=(py*sj0);
IkReal x460=(cj1*py);
IkReal x461=(pz*sj1);
if( IKabs(((-0.311208416129883)+(((0.000806304287963707)*cj1))+(((-1.0)*x456*x457))+(((-10.4560234104301)*x459))+(((-0.0273322931534277)*x461))+(((-1.0)*px*x458))+(((0.0273322931534277)*cj0*x460)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.814157992681073)+(((0.0273322931534277)*x459))+(((-10.4560234104301)*x461))+(((-10.4560234104301)*px*x457))+((cj0*x456))+(((0.308453317969092)*cj1))+((x458*x460)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311208416129883)+(((0.000806304287963707)*cj1))+(((-1.0)*x456*x457))+(((-10.4560234104301)*x459))+(((-0.0273322931534277)*x461))+(((-1.0)*px*x458))+(((0.0273322931534277)*cj0*x460))))+IKsqr(((0.814157992681073)+(((0.0273322931534277)*x459))+(((-10.4560234104301)*x461))+(((-10.4560234104301)*px*x457))+((cj0*x456))+(((0.308453317969092)*cj1))+((x458*x460))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.311208416129883)+(((0.000806304287963707)*cj1))+(((-1.0)*x456*x457))+(((-10.4560234104301)*x459))+(((-0.0273322931534277)*x461))+(((-1.0)*px*x458))+(((0.0273322931534277)*cj0*x460))), ((0.814157992681073)+(((0.0273322931534277)*x459))+(((-10.4560234104301)*x461))+(((-10.4560234104301)*px*x457))+((cj0*x456))+(((0.308453317969092)*cj1))+((x458*x460))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x462=IKcos(j3);
IkReal x463=IKsin(j3);
IkReal x464=((1.0)*px);
evalcond[0]=((-0.02996689)+(((-1.0)*cj0*x464))+(((0.00025)*x462))+(((-1.0)*py*sj0))+(((-0.095638)*x463)));
evalcond[1]=((0.07778664)+(((0.02950006)*cj1))+(((-1.0)*pz*sj1))+((cj0*cj1*py))+(((-0.095638)*x462))+(((-1.0)*cj1*sj0*x464))+(((-0.00025)*x463)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x465=(cj0*px);
IkReal x466=(py*sj0);
IkReal x467=(cj1*pz);
IkReal x468=(cj0*py*sj1);
IkReal x469=(px*sj0*sj1);
if( IKabs(((-0.3064353777765)+(((0.0273322931534277)*x469))+(((-0.000806304287963707)*sj1))+(((-10.4560234104301)*x465))+(((-10.4560234104301)*x466))+(((-0.0273322931534277)*x467))+(((-0.0273322931534277)*x468)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.64009336084448)+(((10.4560234104301)*x469))+(((0.0273322931534277)*x466))+(((0.0273322931534277)*x465))+(((-10.4560234104301)*x468))+(((-10.4560234104301)*x467))+(((-0.308453317969092)*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.3064353777765)+(((0.0273322931534277)*x469))+(((-0.000806304287963707)*sj1))+(((-10.4560234104301)*x465))+(((-10.4560234104301)*x466))+(((-0.0273322931534277)*x467))+(((-0.0273322931534277)*x468))))+IKsqr(((2.64009336084448)+(((10.4560234104301)*x469))+(((0.0273322931534277)*x466))+(((0.0273322931534277)*x465))+(((-10.4560234104301)*x468))+(((-10.4560234104301)*x467))+(((-0.308453317969092)*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.3064353777765)+(((0.0273322931534277)*x469))+(((-0.000806304287963707)*sj1))+(((-10.4560234104301)*x465))+(((-10.4560234104301)*x466))+(((-0.0273322931534277)*x467))+(((-0.0273322931534277)*x468))), ((2.64009336084448)+(((10.4560234104301)*x469))+(((0.0273322931534277)*x466))+(((0.0273322931534277)*x465))+(((-10.4560234104301)*x468))+(((-10.4560234104301)*x467))+(((-0.308453317969092)*sj1))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x470=IKcos(j3);
IkReal x471=IKsin(j3);
IkReal x472=((1.0)*cj0);
evalcond[0]=((-0.02996689)+(((-0.095638)*x471))+(((0.00025)*x470))+(((-1.0)*px*x472))+(((-1.0)*py*sj0)));
evalcond[1]=((0.25241664)+(((-0.095638)*x470))+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-0.02950006)*sj1))+(((-0.00025)*x471))+(((-1.0)*py*sj1*x472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x473=((0.0273322931534277)*sj1);
IkReal x474=(cj0*py);
IkReal x475=((10.4560234104301)*px);
IkReal x476=(py*sj0);
IkReal x477=(cj1*pz);
if( IKabs(((-0.315984187712581)+(((0.0273322931534277)*x477))+((x473*x474))+(((-1.0)*cj0*x475))+(((-10.4560234104301)*x476))+(((-1.0)*px*sj0*x473))+(((0.000806304287963707)*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.01282297782337)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x476))+(((-1.0)*sj0*sj1*x475))+(((10.4560234104301)*sj1*x474))+(((0.0273322931534277)*cj0*px))+(((10.4560234104301)*x477)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.315984187712581)+(((0.0273322931534277)*x477))+((x473*x474))+(((-1.0)*cj0*x475))+(((-10.4560234104301)*x476))+(((-1.0)*px*sj0*x473))+(((0.000806304287963707)*sj1))))+IKsqr(((-1.01282297782337)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x476))+(((-1.0)*sj0*sj1*x475))+(((10.4560234104301)*sj1*x474))+(((0.0273322931534277)*cj0*px))+(((10.4560234104301)*x477))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.315984187712581)+(((0.0273322931534277)*x477))+((x473*x474))+(((-1.0)*cj0*x475))+(((-10.4560234104301)*x476))+(((-1.0)*px*sj0*x473))+(((0.000806304287963707)*sj1))), ((-1.01282297782337)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x476))+(((-1.0)*sj0*sj1*x475))+(((10.4560234104301)*sj1*x474))+(((0.0273322931534277)*cj0*px))+(((10.4560234104301)*x477))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x478=IKcos(j3);
IkReal x479=IKsin(j3);
IkReal x480=((1.0)*cj0);
evalcond[0]=((-0.02996689)+(((-0.095638)*x479))+(((0.00025)*x478))+(((-1.0)*px*x480))+(((-1.0)*py*sj0)));
evalcond[1]=((0.09694336)+(((0.095638)*x478))+(((0.00025)*x479))+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-0.02950006)*sj1))+(((-1.0)*py*sj1*x480)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x481=((31250000.0)*cj0);
IkReal x482=(py*sj1);
IkReal x483=((11954750000.0)*cj2);
IkReal x484=(py*sj0);
IkReal x485=(cj1*pz);
IkReal x486=(px*sj0*sj1);
CheckValue<IkReal> x487=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x487.valid){
continue;
}
CheckValue<IkReal> x488 = IKatan2WithCheck(IkReal(((5458750.0)+(((31250000.0)*x486))+(((-1.0)*x483*x484))+(((-8803233.75)*sj2))+(((-1.0)*x481*x482))+(((-921876.875)*sj1))+(((-1.0)*cj0*px*x483))+(((-31250000.0)*x485))+(((-355817408.2275)*cj2)))),IkReal(((2088255730.0)+(((930258562.3525)*cj2))+(((-11954750000.0)*x485))+(((11954750000.0)*x486))+(((-352665842.285)*sj1))+(((31250000.0)*cj2*x484))+(((-11954750000.0)*cj0*x482))+((cj2*px*x481))+(((-3367694677.53)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x488.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x487.value)))+(x488.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x489=IKcos(j3);
IkReal x490=IKsin(j3);
IkReal x491=((1.0)*cj1);
IkReal x492=(px*sj0);
IkReal x493=(cj0*py);
IkReal x494=((1.0)*sj1);
IkReal x495=((0.00025)*x490);
IkReal x496=((0.095638)*x489);
evalcond[0]=((-0.02996689)+(((0.00025)*x489))+(((-0.095638)*x490))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[1]=((5.0e-5)+(((-1.0)*x491*x492))+(((0.02950006)*cj1))+(((-0.07773664)*sj2))+((sj2*x496))+((sj2*x495))+((cj1*x493))+(((-1.0)*pz*x494))+(((-0.28170348)*cj2)));
evalcond[2]=((0.17468)+(((0.07773664)*cj2))+(((-1.0)*cj2*x496))+(((-1.0)*cj2*x495))+(((-1.0)*x493*x494))+(((-0.02950006)*sj1))+((sj1*x492))+(((-1.0)*pz*x491))+(((-0.28170348)*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x497=((31250000.0)*sj0);
IkReal x498=(py*sj2);
IkReal x499=(cj1*px);
IkReal x500=(pz*sj1);
IkReal x501=((11954750000.0)*sj0);
IkReal x502=(cj0*px*sj2);
IkReal x503=(cj0*cj1*py);
CheckValue<IkReal> x504=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x504.valid){
continue;
}
CheckValue<IkReal> x505 = IKatan2WithCheck(IkReal(((-1562.5)+(((-355817408.2275)*sj2))+((x497*x499))+(((-31250000.0)*x503))+(((31250000.0)*x500))+(((-921876.875)*cj1))+(((-11954750000.0)*x502))+(((-1.0)*x498*x501))+(((8803233.75)*cj2)))),IkReal(((-597737.5)+(((3367694677.53)*cj2))+(((930258562.3525)*sj2))+((x497*x498))+(((-352665842.285)*cj1))+(((11954750000.0)*x500))+(((31250000.0)*x502))+(((-11954750000.0)*x503))+((x499*x501)))),IKFAST_ATAN2_MAGTHRESH);
if(!x505.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x504.value)))+(x505.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x506=IKcos(j3);
IkReal x507=IKsin(j3);
IkReal x508=((1.0)*cj1);
IkReal x509=(px*sj0);
IkReal x510=(cj0*py);
IkReal x511=((1.0)*sj1);
IkReal x512=((0.00025)*x507);
IkReal x513=((0.095638)*x506);
evalcond[0]=((-0.02996689)+(((0.00025)*x506))+(((-0.095638)*x507))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[1]=((5.0e-5)+(((-1.0)*x508*x509))+(((0.02950006)*cj1))+(((-0.07773664)*sj2))+((cj1*x510))+(((-1.0)*pz*x511))+((sj2*x512))+((sj2*x513))+(((-0.28170348)*cj2)));
evalcond[2]=((0.17468)+(((-1.0)*pz*x508))+(((0.07773664)*cj2))+((sj1*x509))+(((-1.0)*cj2*x513))+(((-1.0)*cj2*x512))+(((-0.02950006)*sj1))+(((-1.0)*x510*x511))+(((-0.28170348)*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x514=((0.0273322931534277)*px);
IkReal x515=(cj1*sj0);
IkReal x516=((10.4560234104301)*cj0);
IkReal x517=(py*sj0);
IkReal x518=(cj1*py);
IkReal x519=(pz*sj1);
if( IKabs(((0.315457857396368)+((px*x516))+((x514*x515))+(((-0.0273322931534277)*cj0*x518))+(((0.0273322931534277)*x519))+(((10.4560234104301)*x517))+(((-0.000806304287963707)*cj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.811474262695277)+((cj0*x514))+((x516*x518))+(((-10.4560234104301)*px*x515))+(((0.0273322931534277)*x517))+(((0.308453317969092)*cj1))+(((-10.4560234104301)*x519)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.315457857396368)+((px*x516))+((x514*x515))+(((-0.0273322931534277)*cj0*x518))+(((0.0273322931534277)*x519))+(((10.4560234104301)*x517))+(((-0.000806304287963707)*cj1))))+IKsqr(((-0.811474262695277)+((cj0*x514))+((x516*x518))+(((-10.4560234104301)*px*x515))+(((0.0273322931534277)*x517))+(((0.308453317969092)*cj1))+(((-10.4560234104301)*x519))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.315457857396368)+((px*x516))+((x514*x515))+(((-0.0273322931534277)*cj0*x518))+(((0.0273322931534277)*x519))+(((10.4560234104301)*x517))+(((-0.000806304287963707)*cj1))), ((-0.811474262695277)+((cj0*x514))+((x516*x518))+(((-10.4560234104301)*px*x515))+(((0.0273322931534277)*x517))+(((0.308453317969092)*cj1))+(((-10.4560234104301)*x519))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x520=IKsin(j3);
IkReal x521=IKcos(j3);
IkReal x522=((1.0)*px);
evalcond[0]=((-0.02996689)+(((0.00025)*x521))+(((-1.0)*cj0*x522))+(((-1.0)*py*sj0))+(((0.095638)*x520)));
evalcond[1]=((-0.07768664)+(((-1.0)*cj1*sj0*x522))+(((0.02950006)*cj1))+(((0.00025)*x520))+(((-1.0)*pz*sj1))+((cj0*cj1*py))+(((-0.095638)*x521)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x523=((10.4560234104301)*cj0);
IkReal x524=(py*sj0);
IkReal x525=(cj1*py);
IkReal x526=(pz*sj1);
IkReal x527=((0.0273322931534277)*cj0);
IkReal x528=(cj1*px*sj0);
if( IKabs(((0.315460590625683)+(((0.000806304287963707)*cj1))+(((10.4560234104301)*x524))+((x525*x527))+((px*x523))+(((-0.0273322931534277)*x528))+(((-0.0273322931534277)*x526)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.81251986503632)+(((0.0273322931534277)*x524))+(((-1.0)*x523*x525))+(((10.4560234104301)*x528))+(((10.4560234104301)*x526))+(((-0.308453317969092)*cj1))+((px*x527)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.315460590625683)+(((0.000806304287963707)*cj1))+(((10.4560234104301)*x524))+((x525*x527))+((px*x523))+(((-0.0273322931534277)*x528))+(((-0.0273322931534277)*x526))))+IKsqr(((-0.81251986503632)+(((0.0273322931534277)*x524))+(((-1.0)*x523*x525))+(((10.4560234104301)*x528))+(((10.4560234104301)*x526))+(((-0.308453317969092)*cj1))+((px*x527))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.315460590625683)+(((0.000806304287963707)*cj1))+(((10.4560234104301)*x524))+((x525*x527))+((px*x523))+(((-0.0273322931534277)*x528))+(((-0.0273322931534277)*x526))), ((-0.81251986503632)+(((0.0273322931534277)*x524))+(((-1.0)*x523*x525))+(((10.4560234104301)*x528))+(((10.4560234104301)*x526))+(((-0.308453317969092)*cj1))+((px*x527))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x529=IKcos(j3);
IkReal x530=IKsin(j3);
IkReal x531=((1.0)*px);
evalcond[0]=((-0.02996689)+(((0.00025)*x529))+(((-1.0)*cj0*x531))+(((-1.0)*py*sj0))+(((0.095638)*x530)));
evalcond[1]=((0.07778664)+(((-1.0)*cj1*sj0*x531))+(((0.02950006)*cj1))+(((-0.00025)*x530))+(((-1.0)*pz*sj1))+((cj0*cj1*py))+(((0.095638)*x529)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x532=((0.0273322931534277)*sj1);
IkReal x533=(cj0*py);
IkReal x534=((10.4560234104301)*px);
IkReal x535=(py*sj0);
IkReal x536=(cj1*pz);
if( IKabs(((0.320233628979066)+(((-1.0)*x532*x533))+((cj0*x534))+(((-0.000806304287963707)*sj1))+((px*sj0*x532))+(((10.4560234104301)*x535))+(((-0.0273322931534277)*x536)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.63845523319972)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x535))+(((10.4560234104301)*x536))+(((-1.0)*sj0*sj1*x534))+(((10.4560234104301)*sj1*x533))+(((0.0273322931534277)*cj0*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.320233628979066)+(((-1.0)*x532*x533))+((cj0*x534))+(((-0.000806304287963707)*sj1))+((px*sj0*x532))+(((10.4560234104301)*x535))+(((-0.0273322931534277)*x536))))+IKsqr(((-2.63845523319972)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x535))+(((10.4560234104301)*x536))+(((-1.0)*sj0*sj1*x534))+(((10.4560234104301)*sj1*x533))+(((0.0273322931534277)*cj0*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.320233628979066)+(((-1.0)*x532*x533))+((cj0*x534))+(((-0.000806304287963707)*sj1))+((px*sj0*x532))+(((10.4560234104301)*x535))+(((-0.0273322931534277)*x536))), ((-2.63845523319972)+(((0.308453317969092)*sj1))+(((0.0273322931534277)*x535))+(((10.4560234104301)*x536))+(((-1.0)*sj0*sj1*x534))+(((10.4560234104301)*sj1*x533))+(((0.0273322931534277)*cj0*px))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x537=IKcos(j3);
IkReal x538=IKsin(j3);
IkReal x539=((1.0)*cj0);
evalcond[0]=((-0.02996689)+(((-1.0)*px*x539))+(((0.00025)*x537))+(((-1.0)*py*sj0))+(((0.095638)*x538)));
evalcond[1]=((0.25241664)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-0.02950006)*sj1))+(((-0.00025)*x538))+(((-1.0)*py*sj1*x539))+(((0.095638)*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x540=(cj0*px);
IkReal x541=(py*sj0);
IkReal x542=(cj1*pz);
IkReal x543=(cj0*py*sj1);
IkReal x544=(px*sj0*sj1);
if( IKabs(((0.310684819042985)+(((0.0273322931534277)*x542))+(((0.0273322931534277)*x543))+(((10.4560234104301)*x540))+(((10.4560234104301)*x541))+(((-0.0273322931534277)*x544))+(((0.000806304287963707)*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.01446110546813)+(((0.0273322931534277)*x540))+(((0.0273322931534277)*x541))+(((10.4560234104301)*x544))+(((-0.308453317969092)*sj1))+(((-10.4560234104301)*x542))+(((-10.4560234104301)*x543)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.310684819042985)+(((0.0273322931534277)*x542))+(((0.0273322931534277)*x543))+(((10.4560234104301)*x540))+(((10.4560234104301)*x541))+(((-0.0273322931534277)*x544))+(((0.000806304287963707)*sj1))))+IKsqr(((1.01446110546813)+(((0.0273322931534277)*x540))+(((0.0273322931534277)*x541))+(((10.4560234104301)*x544))+(((-0.308453317969092)*sj1))+(((-10.4560234104301)*x542))+(((-10.4560234104301)*x543))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.310684819042985)+(((0.0273322931534277)*x542))+(((0.0273322931534277)*x543))+(((10.4560234104301)*x540))+(((10.4560234104301)*x541))+(((-0.0273322931534277)*x544))+(((0.000806304287963707)*sj1))), ((1.01446110546813)+(((0.0273322931534277)*x540))+(((0.0273322931534277)*x541))+(((10.4560234104301)*x544))+(((-0.308453317969092)*sj1))+(((-10.4560234104301)*x542))+(((-10.4560234104301)*x543))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x545=IKsin(j3);
IkReal x546=IKcos(j3);
IkReal x547=((1.0)*cj0);
evalcond[0]=((-0.02996689)+(((-1.0)*px*x547))+(((0.00025)*x546))+(((-1.0)*py*sj0))+(((0.095638)*x545)));
evalcond[1]=((0.09694336)+((px*sj0*sj1))+(((-1.0)*cj1*pz))+(((-0.02950006)*sj1))+(((0.00025)*x545))+(((-1.0)*py*sj1*x547))+(((-0.095638)*x546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x548=((31250000.0)*cj0);
IkReal x549=(py*sj1);
IkReal x550=((11954750000.0)*cj2);
IkReal x551=(py*sj0);
IkReal x552=(cj1*pz);
IkReal x553=(px*sj0*sj1);
CheckValue<IkReal> x554 = IKatan2WithCheck(IkReal(((5458750.0)+(((-31250000.0)*x552))+(((31250000.0)*x553))+((cj0*px*x550))+(((360675948.2275)*cj2))+(((-921876.875)*sj1))+((x550*x551))+(((-1.0)*x548*x549))+(((-8885915.0)*sj2)))),IkReal(((-2088255730.0)+(((31250000.0)*cj2*x551))+(((-928385631.7275)*cj2))+(((-11954750000.0)*x553))+(((3399324555.08)*sj2))+(((352665842.285)*sj1))+(((11954750000.0)*x552))+(((11954750000.0)*cj0*x549))+((cj2*px*x548)))),IKFAST_ATAN2_MAGTHRESH);
if(!x554.valid){
continue;
}
CheckValue<IkReal> x555=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x555.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x554.value)+(((1.5707963267949)*(x555.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x556=IKsin(j3);
IkReal x557=IKcos(j3);
IkReal x558=((1.0)*cj1);
IkReal x559=(px*sj0);
IkReal x560=(cj0*py);
IkReal x561=((1.0)*sj1);
IkReal x562=((0.00025)*x556);
IkReal x563=((0.095638)*x557);
evalcond[0]=((-0.02996689)+(((0.095638)*x556))+(((-1.0)*py*sj0))+(((0.00025)*x557))+(((-1.0)*cj0*px)));
evalcond[1]=((5.0e-5)+((cj1*x560))+(((0.02950006)*cj1))+(((-1.0)*pz*x561))+(((-0.07773664)*sj2))+(((-1.0)*x558*x559))+(((-1.0)*sj2*x563))+((sj2*x562))+(((-0.28434928)*cj2)));
evalcond[2]=((0.17468)+(((-0.28434928)*sj2))+((sj1*x559))+(((0.07773664)*cj2))+((cj2*x563))+(((-0.02950006)*sj1))+(((-1.0)*x560*x561))+(((-1.0)*pz*x558))+(((-1.0)*cj2*x562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x564=((31250000.0)*sj2);
IkReal x565=(py*sj0);
IkReal x566=(cj0*px);
IkReal x567=((11954750000.0)*sj2);
IkReal x568=((11954750000.0)*cj1);
IkReal x569=(cj0*py);
IkReal x570=(px*sj0);
IkReal x571=((31250000.0)*cj1);
IkReal x572=(pz*sj1);
CheckValue<IkReal> x573 = IKatan2WithCheck(IkReal(((-1562.5)+(((8885915.0)*cj2))+((x566*x567))+(((-1.0)*x569*x571))+((x565*x567))+(((360675948.2275)*sj2))+(((31250000.0)*x572))+(((-921876.875)*cj1))+((x570*x571)))),IkReal(((597737.5)+((x564*x565))+((x564*x566))+(((-11954750000.0)*x572))+(((352665842.285)*cj1))+(((-3399324555.08)*cj2))+(((-1.0)*x568*x570))+(((-928385631.7275)*sj2))+((x568*x569)))),IKFAST_ATAN2_MAGTHRESH);
if(!x573.valid){
continue;
}
CheckValue<IkReal> x574=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x574.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x573.value)+(((1.5707963267949)*(x574.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x575=IKsin(j3);
IkReal x576=IKcos(j3);
IkReal x577=((1.0)*cj1);
IkReal x578=(px*sj0);
IkReal x579=(cj0*py);
IkReal x580=((1.0)*sj1);
IkReal x581=((0.00025)*x575);
IkReal x582=((0.095638)*x576);
evalcond[0]=((-0.02996689)+(((0.00025)*x576))+(((0.095638)*x575))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[1]=((5.0e-5)+(((-1.0)*sj2*x582))+(((-1.0)*pz*x580))+((sj2*x581))+(((-1.0)*x577*x578))+(((0.02950006)*cj1))+(((-0.07773664)*sj2))+((cj1*x579))+(((-0.28434928)*cj2)));
evalcond[2]=((0.17468)+(((-0.28434928)*sj2))+((sj1*x578))+(((0.07773664)*cj2))+(((-1.0)*x579*x580))+(((-0.02950006)*sj1))+(((-1.0)*pz*x577))+((cj2*x582))+(((-1.0)*cj2*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=0;
cj2=1.0;
j2=0;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs((((r01*sj0))+((cj0*r00)))))+(IKabs(((((-1.0)*r00*sj0*sj1))+((cj1*r02))+((cj0*r01*sj1))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=1.0;
j2=0;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=1.0;
j2=0;
j3eval[0]=cj4;
j3eval[1]=((((-1.0)*(cj4*cj4)))+(((-72.2942021316804)*cj4*sj4)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x583=(r01*sj0);
IkReal x584=(cj0*r00);
IkReal x585=(cj4*sj1);
IkReal x586=(x583+x584);
CheckValue<IkReal> x587=IKPowWithIntegerCheck(cj4,-1);
if(!x587.valid){
continue;
}
CheckValue<IkReal> x588=IKPowWithIntegerCheck(((((-382.552)*cj4*sj4))+(((-5.2916)*(cj4*cj4)))),-1);
if(!x588.valid){
continue;
}
if( IKabs((x586*(x587.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x588.value)*(((((4000.0)*cj0*py*x585))+(((4000.0)*cj1*cj4*pz))+x586+(((-4000.0)*px*sj0*x585))+(((118.00024)*x585))+(((-1009.66656)*cj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x586*(x587.value)))+IKsqr(((x588.value)*(((((4000.0)*cj0*py*x585))+(((4000.0)*cj1*cj4*pz))+x586+(((-4000.0)*px*sj0*x585))+(((118.00024)*x585))+(((-1009.66656)*cj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x586*(x587.value)), ((x588.value)*(((((4000.0)*cj0*py*x585))+(((4000.0)*cj1*cj4*pz))+x586+(((-4000.0)*px*sj0*x585))+(((118.00024)*x585))+(((-1009.66656)*cj4))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x589=IKcos(j3);
IkReal x590=IKsin(j3);
IkReal x591=(sj0*sj1);
IkReal x592=((1.0)*cj1);
IkReal x593=((0.095638)*sj4);
IkReal x594=((1.0)*cj0);
IkReal x595=((1.0)*sj0);
IkReal x596=(sj1*x594);
IkReal x597=(cj4*x589);
IkReal x598=(cj4*x590);
evalcond[0]=((((-1.0)*r01*x595))+(((-1.0)*r00*x594))+x598);
evalcond[1]=((((-1.0)*r01*x596))+((r00*x591))+x597+(((-1.0)*r02*x592)));
evalcond[2]=((-0.02996689)+(((-0.0013229)*x598))+(((-1.0)*px*x594))+(((-1.0)*py*x595))+(((0.00025)*x589))+(((-1.0)*x590*x593)));
evalcond[3]=((0.25241664)+(((-0.0013229)*x597))+(((-1.0)*x589*x593))+(((-1.0)*py*x596))+(((-1.0)*pz*x592))+(((-0.02950006)*sj1))+(((-0.00025)*x590))+((px*x591)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x599=(cj4*sj0);
IkReal x600=(cj0*r00);
IkReal x601=(r01*sj0);
IkReal x602=((382.552)*sj4);
CheckValue<IkReal> x603=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x603.valid){
continue;
}
CheckValue<IkReal> x604 = IKatan2WithCheck(IkReal((x601+x600)),IkReal(((((119.86756)*cj4))+((x601*x602))+(((5.2916)*cj4*x600))+(((5.2916)*r01*x599))+((x600*x602))+(((4000.0)*cj0*cj4*px))+(((4000.0)*py*x599)))),IKFAST_ATAN2_MAGTHRESH);
if(!x604.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x603.value)))+(x604.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x605=IKcos(j3);
IkReal x606=IKsin(j3);
IkReal x607=(sj0*sj1);
IkReal x608=((1.0)*cj1);
IkReal x609=((0.095638)*sj4);
IkReal x610=((1.0)*cj0);
IkReal x611=((1.0)*sj0);
IkReal x612=(sj1*x610);
IkReal x613=(cj4*x605);
IkReal x614=(cj4*x606);
evalcond[0]=((((-1.0)*r00*x610))+(((-1.0)*r01*x611))+x614);
evalcond[1]=(((r00*x607))+(((-1.0)*r01*x612))+x613+(((-1.0)*r02*x608)));
evalcond[2]=((-0.02996689)+(((0.00025)*x605))+(((-0.0013229)*x614))+(((-1.0)*py*x611))+(((-1.0)*x606*x609))+(((-1.0)*px*x610)));
evalcond[3]=((0.25241664)+((px*x607))+(((-0.0013229)*x613))+(((-1.0)*x605*x609))+(((-0.00025)*x606))+(((-0.02950006)*sj1))+(((-1.0)*py*x612))+(((-1.0)*pz*x608)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal((((r01*sj0))+((cj0*r00)))),IkReal(((((-1.0)*r00*sj0*sj1))+((cj1*r02))+((cj0*r01*sj1)))),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
CheckValue<IkReal> x616=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x616.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x615.value)+(((1.5707963267949)*(x616.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x617=IKcos(j3);
IkReal x618=IKsin(j3);
IkReal x619=(sj0*sj1);
IkReal x620=((1.0)*cj1);
IkReal x621=((0.095638)*sj4);
IkReal x622=((1.0)*cj0);
IkReal x623=((1.0)*sj0);
IkReal x624=(sj1*x622);
IkReal x625=(cj4*x617);
IkReal x626=(cj4*x618);
evalcond[0]=((((-1.0)*r01*x623))+(((-1.0)*r00*x622))+x626);
evalcond[1]=(((r00*x619))+(((-1.0)*r02*x620))+(((-1.0)*r01*x624))+x625);
evalcond[2]=((-0.02996689)+(((-0.0013229)*x626))+(((-1.0)*px*x622))+(((-1.0)*x618*x621))+(((0.00025)*x617))+(((-1.0)*py*x623)));
evalcond[3]=((0.25241664)+(((-1.0)*pz*x620))+(((-0.00025)*x618))+((px*x619))+(((-0.02950006)*sj1))+(((-1.0)*x617*x621))+(((-0.0013229)*x625))+(((-1.0)*py*x624)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j3eval[0]=cj4;
j3eval[1]=((IKabs((((r01*sj0))+((cj0*r00)))))+(IKabs((((r00*sj0*sj1))+(((-1.0)*cj0*r01*sj1))+(((-1.0)*cj1*r02))))));
j3eval[2]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j3eval[0]=((((-1.0)*(cj4*cj4)))+(((-72.2942021316804)*cj4*sj4)));
j3eval[1]=cj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x627=((4000.0)*cj4);
IkReal x628=(cj1*r02);
IkReal x629=(r00*sj0*sj1);
IkReal x630=(cj0*r01*sj1);
CheckValue<IkReal> x631=IKPowWithIntegerCheck(((((-382.552)*cj4*sj4))+(((-5.2916)*(cj4*cj4)))),-1);
if(!x631.valid){
continue;
}
CheckValue<IkReal> x632=IKPowWithIntegerCheck(cj4,-1);
if(!x632.valid){
continue;
}
if( IKabs(((x631.value)*(((((119.86756)*cj4))+((cj0*px*x627))+((py*sj0*x627))+x628+x630+(((-1.0)*x629)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x632.value)*((x629+(((-1.0)*x628))+(((-1.0)*x630)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x631.value)*(((((119.86756)*cj4))+((cj0*px*x627))+((py*sj0*x627))+x628+x630+(((-1.0)*x629))))))+IKsqr(((x632.value)*((x629+(((-1.0)*x628))+(((-1.0)*x630))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x631.value)*(((((119.86756)*cj4))+((cj0*px*x627))+((py*sj0*x627))+x628+x630+(((-1.0)*x629))))), ((x632.value)*((x629+(((-1.0)*x628))+(((-1.0)*x630))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x633=IKcos(j3);
IkReal x634=IKsin(j3);
IkReal x635=(sj0*sj1);
IkReal x636=((1.0)*cj1);
IkReal x637=((0.095638)*sj4);
IkReal x638=((1.0)*cj0);
IkReal x639=((1.0)*sj0);
IkReal x640=(sj1*x638);
IkReal x641=(cj4*x634);
IkReal x642=(cj4*x633);
evalcond[0]=((((-1.0)*r01*x639))+(((-1.0)*r00*x638))+x641);
evalcond[1]=((((-1.0)*x642))+(((-1.0)*r01*x640))+(((-1.0)*r02*x636))+((r00*x635)));
evalcond[2]=((-0.02996689)+(((-1.0)*x634*x637))+(((-0.0013229)*x641))+(((0.00025)*x633))+(((-1.0)*px*x638))+(((-1.0)*py*x639)));
evalcond[3]=((0.09694336)+(((-1.0)*pz*x636))+(((0.0013229)*x642))+(((-0.02950006)*sj1))+(((0.00025)*x634))+(((-1.0)*py*x640))+((x633*x637))+((px*x635)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x643=(cj4*sj0);
IkReal x644=(cj0*r00);
IkReal x645=(r01*sj0);
IkReal x646=((382.552)*sj4);
CheckValue<IkReal> x647=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x647.valid){
continue;
}
CheckValue<IkReal> x648 = IKatan2WithCheck(IkReal((x645+x644)),IkReal(((((4000.0)*py*x643))+(((119.86756)*cj4))+(((5.2916)*cj4*x644))+((x644*x646))+(((4000.0)*cj0*cj4*px))+((x645*x646))+(((5.2916)*r01*x643)))),IKFAST_ATAN2_MAGTHRESH);
if(!x648.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x647.value)))+(x648.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x649=IKcos(j3);
IkReal x650=IKsin(j3);
IkReal x651=(sj0*sj1);
IkReal x652=((1.0)*cj1);
IkReal x653=((0.095638)*sj4);
IkReal x654=((1.0)*cj0);
IkReal x655=((1.0)*sj0);
IkReal x656=(sj1*x654);
IkReal x657=(cj4*x650);
IkReal x658=(cj4*x649);
evalcond[0]=((((-1.0)*r00*x654))+(((-1.0)*r01*x655))+x657);
evalcond[1]=((((-1.0)*x658))+(((-1.0)*r01*x656))+(((-1.0)*r02*x652))+((r00*x651)));
evalcond[2]=((-0.02996689)+(((-1.0)*px*x654))+(((0.00025)*x649))+(((-0.0013229)*x657))+(((-1.0)*x650*x653))+(((-1.0)*py*x655)));
evalcond[3]=((0.09694336)+(((0.0013229)*x658))+(((0.00025)*x650))+((x649*x653))+(((-0.02950006)*sj1))+((px*x651))+(((-1.0)*pz*x652))+(((-1.0)*py*x656)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal((((r01*sj0))+((cj0*r00)))),IkReal((((r00*sj0*sj1))+(((-1.0)*cj0*r01*sj1))+(((-1.0)*cj1*r02)))),IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
CheckValue<IkReal> x660=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x660.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x659.value)+(((1.5707963267949)*(x660.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x661=IKcos(j3);
IkReal x662=IKsin(j3);
IkReal x663=(sj0*sj1);
IkReal x664=((1.0)*cj1);
IkReal x665=((0.095638)*sj4);
IkReal x666=((1.0)*cj0);
IkReal x667=((1.0)*sj0);
IkReal x668=(sj1*x666);
IkReal x669=(cj4*x662);
IkReal x670=(cj4*x661);
evalcond[0]=((((-1.0)*r01*x667))+(((-1.0)*r00*x666))+x669);
evalcond[1]=(((r00*x663))+(((-1.0)*r01*x668))+(((-1.0)*x670))+(((-1.0)*r02*x664)));
evalcond[2]=((-0.02996689)+(((-1.0)*x662*x665))+(((-0.0013229)*x669))+(((-1.0)*py*x667))+(((-1.0)*px*x666))+(((0.00025)*x661)));
evalcond[3]=((0.09694336)+((px*x663))+(((-0.02950006)*sj1))+(((-1.0)*py*x668))+((x661*x665))+(((0.0013229)*x670))+(((-1.0)*pz*x664))+(((0.00025)*x662)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
j3eval[2]=((IKabs((((r01*sj0))+((cj0*r00)))))+(IKabs((((cj0*cj1*r01))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*r00*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j3eval[0]=((((-1.0)*(cj4*cj4)))+(((-72.2942021316804)*cj4*sj4)));
j3eval[1]=cj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x671=((4000.0)*cj4);
IkReal x672=(r02*sj1);
IkReal x673=(cj0*cj1*r01);
IkReal x674=(cj1*r00*sj0);
CheckValue<IkReal> x675=IKPowWithIntegerCheck(((((-382.552)*cj4*sj4))+(((-5.2916)*(cj4*cj4)))),-1);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(cj4,-1);
if(!x676.valid){
continue;
}
if( IKabs(((x675.value)*(((((119.86756)*cj4))+((py*sj0*x671))+((cj0*px*x671))+x672+x674+(((-1.0)*x673)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x676.value)*((x673+(((-1.0)*x674))+(((-1.0)*x672)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x675.value)*(((((119.86756)*cj4))+((py*sj0*x671))+((cj0*px*x671))+x672+x674+(((-1.0)*x673))))))+IKsqr(((x676.value)*((x673+(((-1.0)*x674))+(((-1.0)*x672))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x675.value)*(((((119.86756)*cj4))+((py*sj0*x671))+((cj0*px*x671))+x672+x674+(((-1.0)*x673))))), ((x676.value)*((x673+(((-1.0)*x674))+(((-1.0)*x672))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x677=IKcos(j3);
IkReal x678=IKsin(j3);
IkReal x679=(cj0*cj1);
IkReal x680=((0.095638)*sj4);
IkReal x681=((1.0)*sj1);
IkReal x682=((1.0)*cj0);
IkReal x683=((1.0)*sj0);
IkReal x684=(cj1*x683);
IkReal x685=(cj4*x678);
IkReal x686=(cj4*x677);
evalcond[0]=((((-1.0)*r01*x683))+(((-1.0)*r00*x682))+x685);
evalcond[1]=(((r01*x679))+(((-1.0)*r02*x681))+(((-1.0)*r00*x684))+(((-1.0)*x686)));
evalcond[2]=((-0.02996689)+(((-1.0)*x678*x680))+(((-0.0013229)*x685))+(((-1.0)*px*x682))+(((-1.0)*py*x683))+(((0.00025)*x677)));
evalcond[3]=((-0.07768664)+((py*x679))+(((0.02950006)*cj1))+((x677*x680))+(((-1.0)*px*x684))+(((0.00025)*x678))+(((-1.0)*pz*x681))+(((0.0013229)*x686)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x687=(cj4*sj0);
IkReal x688=(cj0*r00);
IkReal x689=(r01*sj0);
IkReal x690=((382.552)*sj4);
CheckValue<IkReal> x691 = IKatan2WithCheck(IkReal((x689+x688)),IkReal((((x688*x690))+(((119.86756)*cj4))+((x689*x690))+(((4000.0)*cj0*cj4*px))+(((5.2916)*cj4*x688))+(((5.2916)*r01*x687))+(((4000.0)*py*x687)))),IKFAST_ATAN2_MAGTHRESH);
if(!x691.valid){
continue;
}
CheckValue<IkReal> x692=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x692.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x691.value)+(((1.5707963267949)*(x692.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x693=IKcos(j3);
IkReal x694=IKsin(j3);
IkReal x695=(cj0*cj1);
IkReal x696=((0.095638)*sj4);
IkReal x697=((1.0)*sj1);
IkReal x698=((1.0)*cj0);
IkReal x699=((1.0)*sj0);
IkReal x700=(cj1*x699);
IkReal x701=(cj4*x694);
IkReal x702=(cj4*x693);
evalcond[0]=((((-1.0)*r00*x698))+(((-1.0)*r01*x699))+x701);
evalcond[1]=((((-1.0)*x702))+(((-1.0)*r02*x697))+(((-1.0)*r00*x700))+((r01*x695)));
evalcond[2]=((-0.02996689)+(((0.00025)*x693))+(((-1.0)*px*x698))+(((-1.0)*x694*x696))+(((-1.0)*py*x699))+(((-0.0013229)*x701)));
evalcond[3]=((-0.07768664)+(((0.0013229)*x702))+(((0.00025)*x694))+(((0.02950006)*cj1))+((py*x695))+((x693*x696))+(((-1.0)*px*x700))+(((-1.0)*pz*x697)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x703=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x703.valid){
continue;
}
CheckValue<IkReal> x704 = IKatan2WithCheck(IkReal((((r01*sj0))+((cj0*r00)))),IkReal((((cj0*cj1*r01))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*r00*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x704.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x703.value)))+(x704.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x705=IKcos(j3);
IkReal x706=IKsin(j3);
IkReal x707=(cj0*cj1);
IkReal x708=((0.095638)*sj4);
IkReal x709=((1.0)*sj1);
IkReal x710=((1.0)*cj0);
IkReal x711=((1.0)*sj0);
IkReal x712=(cj1*x711);
IkReal x713=(cj4*x706);
IkReal x714=(cj4*x705);
evalcond[0]=(x713+(((-1.0)*r01*x711))+(((-1.0)*r00*x710)));
evalcond[1]=((((-1.0)*r02*x709))+((r01*x707))+(((-1.0)*x714))+(((-1.0)*r00*x712)));
evalcond[2]=((-0.02996689)+(((-1.0)*x706*x708))+(((0.00025)*x705))+(((-1.0)*px*x710))+(((-0.0013229)*x713))+(((-1.0)*py*x711)));
evalcond[3]=((-0.07768664)+(((-1.0)*pz*x709))+(((0.0013229)*x714))+(((0.00025)*x706))+(((0.02950006)*cj1))+(((-1.0)*px*x712))+((py*x707))+((x705*x708)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j3eval[0]=cj4;
j3eval[1]=((IKabs((((r01*sj0))+((cj0*r00)))))+(IKabs(((((-1.0)*cj0*cj1*r01))+((r02*sj1))+((cj1*r00*sj0))))));
j3eval[2]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j3eval[0]=cj4;
j3eval[1]=((((-1.0)*(cj4*cj4)))+(((-72.2942021316804)*cj4*sj4)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x715=(r01*sj0);
IkReal x716=(cj0*r00);
IkReal x717=((4000.0)*cj4);
IkReal x718=(x715+x716);
CheckValue<IkReal> x719=IKPowWithIntegerCheck(cj4,-1);
if(!x719.valid){
continue;
}
CheckValue<IkReal> x720=IKPowWithIntegerCheck(((((-382.552)*cj4*sj4))+(((-5.2916)*(cj4*cj4)))),-1);
if(!x720.valid){
continue;
}
if( IKabs((x718*(x719.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x720.value)*((((cj1*px*sj0*x717))+(((-1.0)*cj0*cj1*py*x717))+(((-118.00024)*cj1*cj4))+((pz*sj1*x717))+x718+(((-311.14656)*cj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x718*(x719.value)))+IKsqr(((x720.value)*((((cj1*px*sj0*x717))+(((-1.0)*cj0*cj1*py*x717))+(((-118.00024)*cj1*cj4))+((pz*sj1*x717))+x718+(((-311.14656)*cj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x718*(x719.value)), ((x720.value)*((((cj1*px*sj0*x717))+(((-1.0)*cj0*cj1*py*x717))+(((-118.00024)*cj1*cj4))+((pz*sj1*x717))+x718+(((-311.14656)*cj4))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x721=IKcos(j3);
IkReal x722=IKsin(j3);
IkReal x723=(cj0*cj1);
IkReal x724=((1.0)*sj1);
IkReal x725=((0.095638)*sj4);
IkReal x726=((1.0)*cj0);
IkReal x727=((1.0)*sj0);
IkReal x728=(cj1*x727);
IkReal x729=(cj4*x721);
IkReal x730=(cj4*x722);
evalcond[0]=((((-1.0)*r00*x726))+x730+(((-1.0)*r01*x727)));
evalcond[1]=((((-1.0)*r00*x728))+(((-1.0)*r02*x724))+((r01*x723))+x729);
evalcond[2]=((-0.02996689)+(((-1.0)*x722*x725))+(((-1.0)*px*x726))+(((-1.0)*py*x727))+(((-0.0013229)*x730))+(((0.00025)*x721)));
evalcond[3]=((0.07778664)+(((-0.00025)*x722))+(((0.02950006)*cj1))+(((-1.0)*px*x728))+(((-1.0)*x721*x725))+((py*x723))+(((-0.0013229)*x729))+(((-1.0)*pz*x724)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x731=(cj4*sj0);
IkReal x732=(cj0*r00);
IkReal x733=(r01*sj0);
IkReal x734=((382.552)*sj4);
CheckValue<IkReal> x735 = IKatan2WithCheck(IkReal((x733+x732)),IkReal(((((119.86756)*cj4))+(((5.2916)*cj4*x732))+(((4000.0)*cj0*cj4*px))+((x733*x734))+(((4000.0)*py*x731))+(((5.2916)*r01*x731))+((x732*x734)))),IKFAST_ATAN2_MAGTHRESH);
if(!x735.valid){
continue;
}
CheckValue<IkReal> x736=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x736.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x735.value)+(((1.5707963267949)*(x736.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x737=IKcos(j3);
IkReal x738=IKsin(j3);
IkReal x739=(cj0*cj1);
IkReal x740=((1.0)*sj1);
IkReal x741=((0.095638)*sj4);
IkReal x742=((1.0)*cj0);
IkReal x743=((1.0)*sj0);
IkReal x744=(cj1*x743);
IkReal x745=(cj4*x737);
IkReal x746=(cj4*x738);
evalcond[0]=((((-1.0)*r00*x742))+(((-1.0)*r01*x743))+x746);
evalcond[1]=(((r01*x739))+(((-1.0)*r02*x740))+(((-1.0)*r00*x744))+x745);
evalcond[2]=((-0.02996689)+(((-1.0)*px*x742))+(((-1.0)*x738*x741))+(((-0.0013229)*x746))+(((-1.0)*py*x743))+(((0.00025)*x737)));
evalcond[3]=((0.07778664)+(((-0.00025)*x738))+(((-1.0)*px*x744))+(((-1.0)*x737*x741))+(((0.02950006)*cj1))+(((-1.0)*pz*x740))+(((-0.0013229)*x745))+((py*x739)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x747 = IKatan2WithCheck(IkReal((((r01*sj0))+((cj0*r00)))),IkReal(((((-1.0)*cj0*cj1*r01))+((r02*sj1))+((cj1*r00*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x748.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x747.value)+(((1.5707963267949)*(x748.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x749=IKcos(j3);
IkReal x750=IKsin(j3);
IkReal x751=(cj0*cj1);
IkReal x752=((1.0)*sj1);
IkReal x753=((0.095638)*sj4);
IkReal x754=((1.0)*cj0);
IkReal x755=((1.0)*sj0);
IkReal x756=(cj1*x755);
IkReal x757=(cj4*x749);
IkReal x758=(cj4*x750);
evalcond[0]=((((-1.0)*r01*x755))+(((-1.0)*r00*x754))+x758);
evalcond[1]=((((-1.0)*r02*x752))+((r01*x751))+(((-1.0)*r00*x756))+x757);
evalcond[2]=((-0.02996689)+(((-1.0)*x750*x753))+(((-1.0)*px*x754))+(((0.00025)*x749))+(((-0.0013229)*x758))+(((-1.0)*py*x755)));
evalcond[3]=((0.07778664)+(((-0.00025)*x750))+((py*x751))+(((-1.0)*px*x756))+(((0.02950006)*cj1))+(((-0.0013229)*x757))+(((-1.0)*pz*x752))+(((-1.0)*x749*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x760=IKPowWithIntegerCheck(cj4,-1);
if(!x760.valid){
continue;
}
IkReal x759=x760.value;
CheckValue<IkReal> x761=IKPowWithIntegerCheck(sj2,-1);
if(!x761.valid){
continue;
}
if( IKabs((x759*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x759*(x761.value)*((((cj0*cj1*r01))+(((-1.0)*cj2*sj4))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*r00*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x759*((((r01*sj0))+((cj0*r00))))))+IKsqr((x759*(x761.value)*((((cj0*cj1*r01))+(((-1.0)*cj2*sj4))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*r00*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x759*((((r01*sj0))+((cj0*r00))))), (x759*(x761.value)*((((cj0*cj1*r01))+(((-1.0)*cj2*sj4))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*r00*sj0))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x762=IKcos(j3);
IkReal x763=IKsin(j3);
IkReal x764=(sj2*sj4);
IkReal x765=((1.0)*sj1);
IkReal x766=(cj2*sj4);
IkReal x767=(r00*sj0);
IkReal x768=((1.0)*cj0);
IkReal x769=(cj0*cj1);
IkReal x770=((1.0)*cj1);
IkReal x771=(cj2*cj4);
IkReal x772=((1.0)*sj0);
IkReal x773=(cj4*sj2);
IkReal x774=(px*sj0);
IkReal x775=((0.095638)*x762);
IkReal x776=((0.00025)*x763);
IkReal x777=(cj4*x763);
IkReal x778=((0.0013229)*x762);
evalcond[0]=((((-1.0)*r00*x768))+(((-1.0)*r01*x772))+x777);
evalcond[1]=(((sj1*x767))+(((-1.0)*r02*x770))+(((-1.0)*x764))+(((-1.0)*cj0*r01*x765))+((x762*x771)));
evalcond[2]=((((-1.0)*x767*x770))+(((-1.0)*x762*x773))+(((-1.0)*x766))+(((-1.0)*r02*x765))+((r01*x769)));
evalcond[3]=((-0.02996689)+(((-1.0)*px*x768))+(((-0.095638)*sj4*x763))+(((0.00025)*x762))+(((-0.0013229)*x777))+(((-1.0)*py*x772)));
evalcond[4]=((5.0e-5)+(((0.0013229)*x766))+(((-0.28302638)*cj2))+((x764*x775))+((x773*x778))+(((0.02950006)*cj1))+(((-0.07773664)*sj2))+(((-0.095638)*x771))+((sj2*x776))+((py*x769))+(((-1.0)*x770*x774))+(((-1.0)*pz*x765)));
evalcond[5]=((0.17468)+(((0.0013229)*x764))+(((-1.0)*cj0*py*x765))+(((0.07773664)*cj2))+(((-0.02950006)*sj1))+(((-0.28302638)*sj2))+(((-0.095638)*x773))+(((-1.0)*x766*x775))+(((-1.0)*x771*x778))+((sj1*x774))+(((-1.0)*pz*x770))+(((-1.0)*cj2*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x780=IKPowWithIntegerCheck(cj4,-1);
if(!x780.valid){
continue;
}
IkReal x779=x780.value;
CheckValue<IkReal> x781=IKPowWithIntegerCheck(cj2,-1);
if(!x781.valid){
continue;
}
if( IKabs((x779*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x779*(x781.value)*((((sj2*sj4))+(((-1.0)*r00*sj0*sj1))+((cj1*r02))+((cj0*r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x779*((((r01*sj0))+((cj0*r00))))))+IKsqr((x779*(x781.value)*((((sj2*sj4))+(((-1.0)*r00*sj0*sj1))+((cj1*r02))+((cj0*r01*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x779*((((r01*sj0))+((cj0*r00))))), (x779*(x781.value)*((((sj2*sj4))+(((-1.0)*r00*sj0*sj1))+((cj1*r02))+((cj0*r01*sj1))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x782=IKcos(j3);
IkReal x783=IKsin(j3);
IkReal x784=(sj2*sj4);
IkReal x785=((1.0)*sj1);
IkReal x786=(cj2*sj4);
IkReal x787=(r00*sj0);
IkReal x788=((1.0)*cj0);
IkReal x789=(cj0*cj1);
IkReal x790=((1.0)*cj1);
IkReal x791=(cj2*cj4);
IkReal x792=((1.0)*sj0);
IkReal x793=(cj4*sj2);
IkReal x794=(px*sj0);
IkReal x795=((0.095638)*x782);
IkReal x796=((0.00025)*x783);
IkReal x797=(cj4*x783);
IkReal x798=((0.0013229)*x782);
evalcond[0]=((((-1.0)*r00*x788))+(((-1.0)*r01*x792))+x797);
evalcond[1]=(((x782*x791))+((sj1*x787))+(((-1.0)*cj0*r01*x785))+(((-1.0)*x784))+(((-1.0)*r02*x790)));
evalcond[2]=(((r01*x789))+(((-1.0)*x787*x790))+(((-1.0)*x786))+(((-1.0)*x782*x793))+(((-1.0)*r02*x785)));
evalcond[3]=((-0.02996689)+(((-1.0)*px*x788))+(((0.00025)*x782))+(((-0.095638)*sj4*x783))+(((-0.0013229)*x797))+(((-1.0)*py*x792)));
evalcond[4]=((5.0e-5)+(((0.0013229)*x786))+(((-0.28302638)*cj2))+((x793*x798))+(((0.02950006)*cj1))+(((-0.095638)*x791))+(((-0.07773664)*sj2))+((x784*x795))+((py*x789))+(((-1.0)*x790*x794))+(((-1.0)*pz*x785))+((sj2*x796)));
evalcond[5]=((0.17468)+(((-1.0)*cj0*py*x785))+(((0.0013229)*x784))+(((-1.0)*cj2*x796))+(((0.07773664)*cj2))+((sj1*x794))+(((-0.02950006)*sj1))+(((-0.095638)*x793))+(((-1.0)*x791*x798))+(((-0.28302638)*sj2))+(((-1.0)*x786*x795))+(((-1.0)*pz*x790)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x799=(cj4*sj0);
IkReal x800=(cj0*r00);
IkReal x801=(r01*sj0);
IkReal x802=((382.552)*sj4);
CheckValue<IkReal> x803=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x803.valid){
continue;
}
CheckValue<IkReal> x804 = IKatan2WithCheck(IkReal((x801+x800)),IkReal(((((4000.0)*py*x799))+(((119.86756)*cj4))+(((5.2916)*cj4*x800))+(((5.2916)*r01*x799))+((x800*x802))+(((4000.0)*cj0*cj4*px))+((x801*x802)))),IKFAST_ATAN2_MAGTHRESH);
if(!x804.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x803.value)))+(x804.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x805=IKcos(j3);
IkReal x806=IKsin(j3);
IkReal x807=(sj2*sj4);
IkReal x808=((1.0)*sj1);
IkReal x809=(cj2*sj4);
IkReal x810=(r00*sj0);
IkReal x811=((1.0)*cj0);
IkReal x812=(cj0*cj1);
IkReal x813=((1.0)*cj1);
IkReal x814=(cj2*cj4);
IkReal x815=((1.0)*sj0);
IkReal x816=(cj4*sj2);
IkReal x817=(px*sj0);
IkReal x818=((0.095638)*x805);
IkReal x819=((0.00025)*x806);
IkReal x820=(cj4*x806);
IkReal x821=((0.0013229)*x805);
evalcond[0]=(x820+(((-1.0)*r01*x815))+(((-1.0)*r00*x811)));
evalcond[1]=((((-1.0)*x807))+((sj1*x810))+(((-1.0)*cj0*r01*x808))+(((-1.0)*r02*x813))+((x805*x814)));
evalcond[2]=((((-1.0)*x809))+((r01*x812))+(((-1.0)*r02*x808))+(((-1.0)*x810*x813))+(((-1.0)*x805*x816)));
evalcond[3]=((-0.02996689)+(((-0.0013229)*x820))+(((-0.095638)*sj4*x806))+(((-1.0)*py*x815))+(((-1.0)*px*x811))+(((0.00025)*x805)));
evalcond[4]=((5.0e-5)+((py*x812))+(((-0.28302638)*cj2))+(((0.02950006)*cj1))+((sj2*x819))+((x816*x821))+(((-0.07773664)*sj2))+((x807*x818))+(((-1.0)*x813*x817))+(((-0.095638)*x814))+(((0.0013229)*x809))+(((-1.0)*pz*x808)));
evalcond[5]=((0.17468)+(((-1.0)*cj2*x819))+((sj1*x817))+(((0.07773664)*cj2))+(((-1.0)*x814*x821))+(((-1.0)*x809*x818))+(((-1.0)*pz*x813))+(((-0.02950006)*sj1))+(((-0.28302638)*sj2))+(((-0.095638)*x816))+(((-1.0)*cj0*py*x808))+(((0.0013229)*x807)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - myarm_a1 (863c8dee3e2206cbfbacda3ef8e35523)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
